success = False # в будущем, если победим, примет значение True
mas = list(range(100000)) # создаём массив и наполняем его значениями от 0 до 99999
key = int(input('Введите число для поиска: ')) # вводим число с клавиатуры и преобразуем его в тип int
l = 0  # индекс левой границы массива mas. 0, потому что исчесление элементов в массиве начинается имеенно с нуля
r = mas[len(mas)-1]  # правая граница. В отличие от левой, она может меняться в зависимости от количества элементов в массиве, поэтому мы её вычисляем с помощью функции определения длины len(). Единицу вычитаем, потому что первый элемент в массиве у нас с индексом 0. Например, при длинне массива 100000, последний элемент будет 99999
iterateCounter = 0  # счётчик (англ. counter) повторений (англ. iterations) цикла поиска
mid = None # задаём пустую переменную, заполним её чуть позже. None означает "ничего" 
while ((l <= r)): # выполняем цикл до тех пор, пока выражение (l <= r) не будет равно False
    iterateCounter += 1 # увеличиваем значение счётчика на 1. Ещё можно написать так: iterateCounter = iterateCounter + 1, смысл тот же
    mid = (l + r) // 2  # считываем срединный индекс отрезка [l,r]
    if (mas[mid] == key):  # сверяем введённый нами с клавиатуры key со стрединным значением
        success = True # победа! Теперь наш успех равен True
    if (mas[mid] > key):  # проверяем, какую часть нужно отбросить
        r = mid - 1 # если срединное значение больше искомого, двигаем правую границу r влево и ставим на месте срединной переменной 
        # l - - - - mid <- - - - r
        # l - - - -  r
    else:
        l = mid + 1 
        # l - - - -> mid - - - - - r
        #             l  - - - - - r

if (success == True): # в случае успеха печатаем статистику 
    print("Индекс элемента " + str(key) + " в массиве равен: " + str(mid))
    print("")
    print("Количество циклов поиска искомого числа: "+str(iterateCounter))
else: # иначе извиняемся
    print("Извините, но такого элемента в массиве нет")
